.TH SDL_CreateRGBSurfaceFrom 3 "2018.10.07" "https://github.com/haxpor/sdl2-manpage" "SDL2"
.SH NAME
\fBSDL_CreateRGBSurfaceFrom\fR -- Function

.SH SYNOPSIS
Use this function to allocate a new RGB surface with existing pixel data.

.SH SYNTAX
.TS
tab(:) allbox;
a.
T{
.nf
SDL_Surface* SDL_CreateRGBSurfaceFrom(void*     pixels,
                                      int       width,
                                      int       height,
                                      int       depth,
                                      int       pitch,
                                      Uint32    Rmask,
                                      Uint32    Gmask,
                                      Uint32    Bmask,
                                      Uint32    Amask)
.fi
T}
.TE

.SH FUNCTION PARAMETERS
.TS
tab(:) allbox;
ab l.
pixels:a pointer to existing pixel data
width:the width of the surface
height:the height of the surface
depth:the depth of the surface in bits; see \fBRemarks\fR for details
pitch:the length of a row of pixels in bytes
Rmask:the red mask for the pixels
Gmask:the green mask for the pixels
Bmask:the blue mask for the pixels
Amask:the alpha mask for the pixels
.TE

.SH RETURN VALUE
Returns the new \fBSDL_Surface\fR structure that is created or NULL if it fails; call \fBSDL_GetError()\fR for more information.

.SH CODE EXAMPLES
.TS
tab(:) allbox;
a.
T{
.nf
// This example shows how to create a SDL_Surface* with the data
// loaded from an image file with the stb_image.h library
// (https://github.com/nothings/stb/)

// the color format you request stb_image to utput, use STBI_rgb
// if you don't want/need the alpha channel
int req_format = STBI_rgb_alpha;
int width, height, orig_format;
unsigned char* data = stbi_load("./test.png", &width, &height, &orig_format, req_format);
if (data == NULL) {
  SDL_Log("Loading image failed: %s", stbi_failure_reason());
  exit(1);
}

// Set up the pixel format color masks for RGB(A) byte arrays.
// Only STBI_rgb (3) and STBI_rgb_alpha (4) are supported here!
Uint32 rmask, gmask, bmask, amask;
#if SDL_BYTEORDER == SDL_BIG_ENDIAN
  int shift = (req_format == STBI_rgb) ? 8 : 0;
  rmask = 0xff000000 >> shift;
  gmask = 0x00ff0000 >> shift;
  bmask = 0x0000ff00 >> shift;
  amask = 0x000000ff >> shift;
#else // little endian, like x86
  rmask = 0x000000ff;
  gmask = 0x0000ff00;
  bmask = 0x00ff0000;
  amask = (req_format == STBI_rgb) ? 0 : 0xff000000;
#endif

int depth, pitch;
if (req_format == STBI_rgb) {
  depth = 24;
  pitch = 3*width;  // 3 bytes per pixel * pixels per row
} else {
  depth = 24;
  pitch = 4*width;
}

SDL_Surface* surf = SDL_CreateRGBSurfaceFrom((void*)data, width, height, depth, pitch, rmask, gmask, bmask, amask);

if (surf == NULL) {
  SDL_Log("Creating surface failed: %s", SDL_GetError());
  stbi_image_free(data);
  exit(1);
}

// ... do something useful with the surface ...
// ...

// when you don't need the surface anymore, free it..
SDL_FreeSurface(surf);
// .. *and* the data used by the surface!
stbi_image_free(data);
.fi
T}
.TE

.SH REMARKS
The \fBdepth\fR is 4 or 8 bits, an empty palette is allocated for the surface. If \fBdepth\fR is greater than 8 bits, the pixel format is set using the [RGBA]mask parameters.

The [RGBA]mask parameters are the bitmasks used to extract that color from a pixel. For instance, \fBRmask\fR being FF000000 means the red data is stored in the most significant byte. Using zeros for the RGB masks sets a default value, based on the depth. (e.g. \fBSDL_CreateRGBSurface(0,w,h,32,0,0,0,0)\fR;) However, using zero for the Amask results in an Amask of 0.

By default surfaces with an alhpa mask are set up for blending as with

.IP
SDL_SetSurfaceBlendMode(surface, SDL_BLENDMODE_BLEND)
.PP
You can change this by calling \fBSDL_SetSurfaceBlendMode()\fR and selecting a different \fIblendMode\fR.

No copy is made of the pixel data. Pixel data is not managed automatically; you must free the surface before you free the pixel data.

.SH RELATED FUNCTIONS
\fISDL_CreateRGBSurface
.br
\fISDL_CreateRGBSurfaceWithFormatFrom
.br
\fISDL_FreeSurface
